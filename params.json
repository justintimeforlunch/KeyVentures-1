{"name":"KeyVentures!","tagline":"KeyVentures! An action multiplayer game!","body":"# KeyVentures\r\nEvil Khy and nice-guy Justin are arch enemies. The local king Krishnan of Holyoke has challenged them both to collect all the keys scattered across the universe and win the competition. It is your decision to pick which character to play as.\r\n\r\n##Authors\r\nKhyteang Lim\r\n\r\n\r\nJustin Nguyen \r\n\r\n\r\nRohit Krishnan\r\n\r\n\r\n##Overview\r\nKeyVentures is a multi-player key finding game where two players race against each other to capture the key first. There is a twist where in the beginning of the game, we take a picture of the user to determine whether they will play as the good character or the evil character. Additionally, when a character captures a key by walking over it, we increment the total points that they have. \r\n\r\n##Screenshot\r\n<p align=\"center\">\r\n     <img src=\"http://i.imgur.com/mndA6YT.png?1\"/>\r\n</p>\r\n\r\n##Concepts Demonstrated\r\nIdentify the OPL concepts demonstrated in your project. Be brief. A simple list and example is sufficient. \r\n* **Data abstraction** is used to provide access to the elements of the RSS feed.\r\n* The objects in the OpenGL world are represented with **recursive data structures.**\r\n* **Symbolic language processing techniques** are used in the parser.\r\n* **HashMap** is used to serialize the data in the JSON file so it can be later accessed as key-value pairs.\r\n\r\n##External Technology and Libraries\r\n\r\n<b>Planet Cute</b> We used the planetcute library which contains images drawn by Daniel Cook. These images represent our scenary and characters in the game. The library consists of blocks of images which we put together by stacking them on top of each other and side by side to create our world.\r\n\r\n<b>JSON</b> When we take a picture using the C++ code, the other program will store the results in an file called Outfile.json. We then use the JSON library to serialize that into a hashmap of emotions and values. We then use that to determine whether the user is happy or sad and that is used to pick their character. \r\n\r\n##Favorite Lines of Code\r\n####Khyteang Lim\r\n```scheme\r\n(define (scoreReach30 n) (cond ((= player2score 15) (begin (write evil) #t))\r\n                               ((= player1score 15) (begin (write good) #t))\r\n                               (else #f)))\r\n```\r\nThis code is one of my favorites even though it looks simple. This is a pedicate that returns a boolean value depending on the condition statement that it checks for. This pedicate returns true if one of the players score reaches 15 and false if otherwise. However, what makes this code interesting is the fact that before it returns a boolean value, it performs some executions using the begin procedure. This begin procedure allows multiple executations of procedures before returning the boolean value.  \r\n\r\n####Justin Nguyen\r\n ```scheme\r\n (define (scenes imgs)\r\n   (place-images (list player1 player-name1 player2 player-name2 (count player1score) (count1 player2score) key img) \r\n                (list (htdp:make-posn player1X player1Y)\r\n                       (htdp:make-posn player1X (- player1Y 40))\r\n                       (htdp:make-posn player2X player2Y)\r\n                       (htdp:make-posn player2X (- player2Y 40))\r\n                       (htdp:make-posn 850 65)\r\n                       (htdp:make-posn 50 65)\r\n                       (htdp:make-posn keyX key)\r\n                       (htdp:make-posn 450 303)) window))\r\n```\r\nThis is my favorite lines of code because it is the position of where the images are when the program runs. The (place-images (list...) places the images in the window and the next list is where the images are placed relavent to the window. (player1X and player1Y are global variables)\r\n\r\n\r\n####Rohit Krishnan\r\n```scheme\r\n(define pick-character\r\n  (lambda()\r\n    (begin (take-picture)\r\n           (define result (string->jsexpr\r\n            (file->string (string-append working-directory \"Outfile.json\"))))\r\n           (> (hash-ref result 'happy) (* 3 (hash-ref result 'anger))))))\r\n```\r\nThe piece of code above will read a JSON file in the current working directory and serialize it into a hash table. We then check the 'Happy and 'Anger properties and compare them to see if the user is happy or sad. \r\n\r\n##Additional Remarks\r\nGood luck running this.\r\n\r\n#How to Download and Run\r\n\r\n     -Extract the two things in the archive to the KeyVentures folder. Make sure the .rkt file and the emotime folder are in the same directory.\r\n     -Open up a terminal, cd into emotime/assets and run the following command once: cd ../build; cmake .. ; make clean; make ; make install; cd ../assets; ./emotimegui_cli -s ../resources/haarcascade_frontalface_cbcl1.xml ../resources/haarcascade_eye.xml 52 52 1 5 8 svm ../assets/svm_1vsallext_1_5_8_95c2eb0b58/*\r\n     -Open the gui.rkt file and change the working-directory variable to point to wherever you have the \"emotime\" folder located. In my computer, it was /home/rkrishnan/Documents/OPL/finalProject/emotime, so I set that variable to be /home/rkrishnan/Documents/OPL/finalProject/.  \r\n     -That's it, run the gui.rkt file and start by taking a picture first, then the game will start. To play, navigate with the arrow keys and the WASD keys.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}